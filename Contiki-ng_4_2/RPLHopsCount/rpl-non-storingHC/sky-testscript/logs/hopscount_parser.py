#! /usr/bin/python
# -*- coding: utf-8 -*-

import os
import sys  
import operator
import argparse
from collections import OrderedDict

def hopscount_parser(base_name):

    #Dir, files, and aux vars
    result_dir = 'Parsed_data'
    path = os.getcwd()+'/'+base_name
    files = os.listdir(path)
    sim_conv = False
    sim_stats = {'sim_total':'0','sim_total_conv':'0',
                 'sim_total_no_conv':'0','sim_total_recovered':'0',
                 'sim_total_no_recovered':'0',
                 'sim_total_no_conv':'0',
                 'sim_total_conv':'0',
                 'sim_total_seeds':[],
                 'sim_total_conv_seeds':[],
                 'sim_total_no_conv_seeds':[],
                 'sim_total_recovered_seeds':[],
                 'sim_total_no_recovered_seeds':[]
                 }


    #Create a final dir where it will include parse data
    os.mkdir(path+'/'+result_dir+'/')

    #Param. for the parser -> -ns (non-storing) -s (Storing)
    parser = argparse.ArgumentParser()
    parser.add_argument("strings", metavar="<dir>", type=str, help ="Dir to parse")
    parser.add_argument("-ns", "--nonstoring", help="Non Storing Parsing", action="store_true")
    parser.add_argument("-s", "--storing", help="Storing Parsing", action="store_true")
    args = parser.parse_args()

    #To log all the operations during the parsing
    try:
        log_parser = open(path +'/.hopscount_parser.log', 'w+')
        if args.storing:
            log_parser.write('Mode: Storing activated\n\n')
        elif args.nonstoring:
            log_parser.write('Mode: Non-Storing activated\n\n')
    except:
        print('Error: cannot create the parser logs\n')
    
    #We only want to parse the .scritplog generated by cooja
    for file in files:
        if(file != result_dir):
            if(file.count('scriptlog')):

                try:
                    # Prepare to read
                    file_to_parse = open(path+'/'+file, 'r')
                    log_parser.write('\n\nINFO: Reading the file '+file +'\n')
                    # Stats
                    sim_stats['sim_total'] = str(int( sim_stats['sim_total']) + 1)
                    sim_stats['sim_total_seeds'].append(get_random_seed(file_to_parse))

                except:
                    print('Error, cannot read the file: '+file)

                try:
                    # Prepare to write
                    file_parsed = open(path+'/'+result_dir+'/parsed_'+file,'w')
                    log_parser.write('INFO: Creating the file parsed_'+file+'\n')
                except:
                    print('Error, cannot create the file: parsed_'+file)

                try:
                    #Count the number of motes
                    num_motes=motes_count_per_file(file_to_parse)
                    log_parser.write('INFO: Counting each mote '+'\n')
                except:
                    print('Error, cannot read the number of motes in the file: '+ file)
               
                try:
                    #Recover all ipv6's and parse them to local-ipv6
                    dic_motes_ip = read_ip_modes(file_to_parse)
                    log_parser.write('INFO: Creating data struct for all IPs in the file:' + file +'\n')
                except:
                    print('Error, cannot read motes IP in the file: '+ file)
                
                try:
                    #Create data struct for hops, all with all
                    dic_motes = {0:{'Nothing':'here'}}
                    for i in range(1,num_motes+1):
                        dic_motes[i]  = {}
                        for j in range(1,(num_motes+1)):
                            if(j != i):
                                dic_motes[i].update({str(j):'-'})

                    log_parser.write('INFO: Creating data struct for all hops in the file: '+file+'\n')
                except:
                    print('Error, cannot create data struct in the file: '+ file)

                try:

                    hops_count_per_file(file_to_parse,dic_motes)

                    try: # Stats( Check if this simulation is OK )
                        if get_state_of_sim(dic_motes,file_to_parse) :
                            sim_stats['sim_total_conv'] = str(int( sim_stats['sim_total_conv']) + 1)
                            sim_stats['sim_total_conv_seeds'].append(get_random_seed(file_to_parse))
                        else:
                            sim_stats['sim_total_no_conv'] = str(int( sim_stats['sim_total_no_conv']) + 1)
                            sim_stats['sim_total_no_conv_seeds'].append(get_random_seed(file_to_parse))
                        log_parser.write('INFO: Checking the state of the simulation in the file: '+ file +'\n')
                    except:
                        print('Error, cannot check the state of the simulation in the file: '+ file +'\n')
                    
                    #We are going to complete all posible paths (only non-storing mode)
                    if args.nonstoring:
                        
                        #If there aren't info about the hops to the sink mote, 
                        #We can try to recover this info from ipv6
                        sim_conv = complete_hops_allWall_ns(file_to_parse,dic_motes,dic_motes_ip, sim_stats)
                        
                        #if the simulation didnt converge, just log it
                        if not sim_conv:
                            log_parser.write('Error: Not converged \n')

                    log_parser.write('INFO: reading the hops per mote in the file:' + file +'\n')
                    #print(dic_motes)
                except:
                    print('Error, cannot read the hops per mote in the file: '+ file)

                try:
                    #Just write final result if the simulation converged
                    if sim_conv:
                        write_parsed_data(file_parsed,dic_motes,file,num_motes)
                        log_parser.write('INFO: writing in the file: '+ file+'\n')
                except:
                    print('Error, cannot write in the file: '+ file)
                
                #Close the files
                file_parsed.close()
                file_to_parse.close()

                #Manage if the simulation didnt converge
                if not sim_conv:
                    print('Machacando la simulacion no conv '+file+'\n')
                    manage_not_converged_sim(file,path,result_dir)
    
    #Add the stats in log file
    add_stats_to_results_file(sim_stats,path)
    log_parser.close()
    #Just for order the dir tree
    orderLogDir(path)

def get_random_seed(file_to_parse):
    #   line == Random seed: 123486
    #   aux_line[1] ==  123486
    for line in file_to_parse:
        if line.count('Random seed: '):
            aux_line = line.split(':')
            file_to_parse.seek(0)
            return aux_line[1][1:len(aux_line[1]) -1 ]

    file_to_parse.seek()

def motes_count_per_file(file):
    aux_id = []

    # line == '31804806 ID:1 [INFO: Main      ] Node ID: 1'
    # aux_line[1] == '1 [INFO: Main      ] Node '
    # aux_line2[0]== '1 ' --> '12 '
    # aux_line2[0][0: len(aux_line2[0]) - 1] == 'ID'
    for line in file:
        if(line.count('Node ID: ')):                                            
            aux_line = line.split('ID: ')                                      
            aux_line2 = aux_line[1].split('[')
                                             
            if(not(int(aux_line2[0][0: len(aux_line2[0]) - 1]) in aux_id)):        
                aux_id.append(int(aux_line2[0][0: len(aux_line2[0]) - 1]))

    file.seek(0)  

    return len(aux_id)

def read_ip_modes(file_to_parse):
    dic = {0 : 'Nothing here'}
    ipv6_link_local = ''
    ipv6_local = ''

    for line in file_to_parse:
    # '563087 ID:4 [INFO: Main      ] Tentative link-local IPv6 address: fe80::212:7404:4:404'                  
        if(line.count('Tentative link-local IPv6 address:')):

            aux_line = line.split('ID:')                               
            aux_line2 = aux_line[1].split('[')

            aux_str_ip = line.split('address:')

            #Casting link-local ipv6 to local ipv6 ->( fe80:: ) to ( fd00:: )
            ipv6_link_local = aux_str_ip[1][1:len(aux_str_ip[1]) -1]
            ipv6_local = get_ipv6_local(ipv6_link_local)

            dic[int(aux_line2[0][0: len(aux_line2[0]) - 1])] = ipv6_local

    file_to_parse.seek(0)
    return dic

def get_ipv6_local(ipv6_link_local):

    return ('fd00' + ipv6_link_local[4:])  

def get_state_of_sim(dic_motes,file_to_parse):
    
    for i in range(2, motes_count_per_file(file_to_parse) + 1):
        if dic_motes[1][str(i)] == '-':
            return False

    return True        


def hops_count_per_file(file_to_parse,dic_motes):
    mote_a = 0
    mote_b = 0
    hops_a_to_b = 0

    for line in file_to_parse:
        if(line.count('M[')):
            data = line.split('M[') #Data[1] and data[2] 

            mote_a = int(data[1][0:len(data[1])-2])
            aux_data_split = data[2].split(':')
            
            mote_b = int(aux_data_split[0][0:len(aux_data_split[0])-1])
            hops_a_to_b = int(aux_data_split[1][0:len(aux_data_split[1])-1])
            
            dic_motes[mote_a][str(mote_b)]= str(hops_a_to_b)
            dic_motes[mote_b][str(mote_a)]= str(hops_a_to_b)

    file_to_parse.seek(0)

def complete_hops_allWall_ns(file_to_parse,dic_motes, dic_ip, sim_stats):
    bool_sim_conv = True

    #Initial check for hops to sink
    for i in range(2, motes_count_per_file(file_to_parse) + 1):
        if dic_motes[1][str(i)] == '-':
            bool_sim_conv = use_ip_hops_check(file_to_parse,dic_motes, dic_ip, str(i))
            if  not bool_sim_conv:
                sim_stats['sim_total_no_recovered_seeds'].append(get_random_seed(file_to_parse))
                sim_stats['sim_total_no_recovered'] = str(int( sim_stats['sim_total_no_recovered']) + 1)
                return False
            else:
                sim_stats['sim_total_recovered_seeds'].append(get_random_seed(file_to_parse))
                sim_stats['sim_total_recovered'] = str(int( sim_stats['sim_total_recovered']) + 1)
                

    #Complete all posible paths 
    for i in range(2, motes_count_per_file(file_to_parse) + 1):
        for j in range(2, motes_count_per_file(file_to_parse) +1):
            if i != j:
                dic_motes[i][str(j)] = str(int(dic_motes[1][str(i)]) + int(dic_motes[1][str(j)]))

    return True

def add_stats_to_results_file(sim_stats,path):

    temp_file = open(path+'/'+ 'ParserResults.txt', 'w')
    temp_file.write('\nParser statistics:\n\n')
    temp_file.write('1.\tTotal simulations: '+ sim_stats['sim_total']+'\n')
    temp_file.write('2.\tTotal simulations conv: '+ sim_stats['sim_total_conv']+' ( {:.3f}% )\n'.format(100*float(int(sim_stats['sim_total_conv'])/int(sim_stats['sim_total']))))
    temp_file.write('3.\tTotal simulations no conv: '+sim_stats['sim_total_no_conv']+' ( {:.3f}% )\n'.format(100*float(int(sim_stats['sim_total_no_conv'])/int(sim_stats['sim_total']))))
    temp_file.write('4.\tTotal simulations recovered: '+sim_stats['sim_total_recovered']+' ( {:.3f}% )\n'.format(100*float(int(sim_stats['sim_total_recovered'])/int(sim_stats['sim_total']))))
    temp_file.write('5.\tTotal simulations no recovered: '+sim_stats['sim_total_no_recovered']+' ( {:.3f}% )\n'.format(100*float(int(sim_stats['sim_total_no_recovered'])/int(sim_stats['sim_total'])))) 
    temp_file.write('\n\n-- Parser summary by seeds --\n\n')
    temp_file.write('|     Total simulations     |\n')
    for i in range(0, len(sim_stats['sim_total_seeds'])):
        temp_file.write('\t\t\t\t\t' + sim_stats['sim_total_seeds'][i] + '\t|\n')
    
    temp_file.write('\n\n|  Total simulations Conv   |\n')
    for i in range(0, len(sim_stats['sim_total_conv_seeds'])):
        temp_file.write('\t\t\t\t\t' + sim_stats['sim_total_conv_seeds'][i] + '\t|\n')
    
    temp_file.write('\n\n| Total simulations No Conv |\n')
    for i in range(0, len(sim_stats['sim_total_no_conv_seeds'])):
        temp_file.write('\t\t\t\t\t' + sim_stats['sim_total_no_conv_seeds'][i] + '\t|\n')

    temp_file.write('\n\n|         Recovered         |\n')
    for i in range(0, len(sim_stats['sim_total_recovered_seeds'])):
        temp_file.write('\t\t\t\t\t' + sim_stats['sim_total_recovered_seeds'][i] + '\t|\n')
    
    temp_file.write('\n\n|        No Recovered       |\n')
    for i in range(0, len(sim_stats['sim_total_no_recovered_seeds'])):
        temp_file.write('\t\t\t\t\t' + sim_stats['sim_total_no_recovered_seeds'][i] + '\t|\n')


def use_ip_hops_check(file_to_parse,dic_motes, dic_ip, key):
    bool_sim_conv = False

    for line in file_to_parse:
        if line.count('Ip: '+dic_ip[int(key)]):
            aux_line = line.split(dic_ip[int(key)])
            aux_line2 = aux_line[1].split(': ')

            dic_motes[1][key] = dic_motes[int(key)]['1'] = aux_line2[1][0: len(aux_line2[1]) - 1]
            bool_sim_conv = True

    file_to_parse.seek(0)

    return bool_sim_conv

def write_parsed_data(file_parsed,dic_motes,file,num_motes):
    file_parsed.write('File generated by hopscount_parser.py \n')
    file_parsed.write('Original file name: '+ file + '\n')
    file_parsed.write('Number of motes: '+str(num_motes) +'\n')
    avg=0.0
    aux_avg=0.0
    num_motes_aux=0

    dic_avg_per_mote = {'0':'-'}
    for i in range(1,num_motes+1):
        dic_avg_per_mote.update({str(i):'0'})

    

    for i in range(1,num_motes+1):
        file_parsed.write('\n\nMote['+str(i)+'] | Dest_Mote_ID | Hops\n')
        
        for key in sorted(dic_motes[i]):
            file_parsed.write('\t\t| \t\t\t'+str(key)+' | \t'+ str(dic_motes[i][key])+'\n')
            if(str(dic_motes[i][key]) != '-'):
                avg += float(dic_motes[i][key])
                num_motes_aux+=1
        
        avg /= float(num_motes_aux)
        file_parsed.write('Hops Avg to all motes: '+ str(avg) +'\n')
        dic_avg_per_mote[str(i)] = str(avg)
        avg=0.0
        num_motes_aux=0
    
    for i in range(1,num_motes+1):
        aux_avg+=float(dic_avg_per_mote[str(i)])

    aux_avg /=  float(num_motes)
    file_parsed.write('\n|Total Hops avg all with all: '+str(aux_avg) +'\n') 

def orderLogDir(path):
    cooja_data = 'Cooja_logs'
    raw_data = 'Raw_data'

    #Create dir structe
    os.mkdir(path+'/'+ cooja_data + '/')
    os.mkdir(path +'/'+raw_data+'/')
    os.mkdir(path +'/'+raw_data+'/converged')
    os.mkdir(path +'/'+raw_data+'/no_converged')

    #Move files
    os.system('mv ' + path + '/*.coojalog '+ path + '/' + cooja_data + '/')
    #os.system('mv ' + path + '/no_conv_*.scriptlog '+ path + '/' + raw_data + '/no_converged')
    os.system('mv ' + path + '/*.scriptlog '+ path + '/' + raw_data + '/converged')

def manage_not_converged_sim(file,path,result_dir):

    os.rename(path +'/'+ file, path +'/no_conv_' +file)



if __name__ == '__main__':


    if(len(sys.argv) != 3):
        print('Error: usage: ' + sys.argv[0] + ' -[ns | s]  <dir_log>\n')
        sys.exit(0)

    base_name = sys.argv[2]

    hopscount_parser(base_name)
    print('\nParser status: success')


#   Notas a david del futuro, te queda por hacer:
#   
#   1. Meter la logica para diferenciar una simulacion recuperada(conv - no conv)
#   2. Añadir * cuando venga de una simulación timeout
#   3. Mejorar rendimiento -> optimizar bubles
#   4. Comentar el código más para que Hedayat lo entienda más facilmente
#   5. Terminar el handler para los no recuperados
