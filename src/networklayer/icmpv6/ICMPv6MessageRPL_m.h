//
// Generated file, do not edit! Created by nedtool 5.2 from src/networklayer/icmpv6/ICMPv6MessageRPL.msg.
//

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#ifndef __RPL_ICMPV6MESSAGERPL_M_H
#define __RPL_ICMPV6MESSAGERPL_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0502
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/common/INETDefs.h"
#include "inet/networklayer/contract/ipv6/IPv6Address.h"
#define ICMPv6_HEADER_BYTES  8
// }}


namespace rpl {

// cplusplus {{
using namespace inet;
class inet::IPv6Address;
// }}

/**
 * Enum generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:50</tt> by nedtool.
 * <pre>
 * enum ICMPv6Type
 * {
 * 
 *     ICMPv6_UNSPECIFIED = 0;
 *     ICMPv6_DESTINATION_UNREACHABLE = 1;
 *     ICMPv6_PACKET_TOO_BIG = 2;
 *     ICMPv6_TIME_EXCEEDED = 3;
 *     ICMPv6_PARAMETER_PROBLEM = 4;
 *     ICMPv6_ECHO_REQUEST = 128;
 *     ICMPv6_ECHO_REPLY = 129;
 *     ICMPv6_MLD_QUERY = 130;
 *     ICMPv6_MLD_REPORT = 131;
 *     ICMPv6_MLD_DONE = 132;
 *     ICMPv6_ROUTER_SOL = 133;
 *     ICMPv6_ROUTER_AD = 134;
 *     ICMPv6_NEIGHBOUR_SOL = 135;
 *     ICMPv6_NEIGHBOUR_AD = 136;
 *     ICMPv6_REDIRECT = 137;
 *     ICMPv6_MLDv2_REPORT = 143;
 *     ICMPv6_EXPERIMENTAL_MOBILITY = 150;  //Zarrar Yousaf 02.08.07 (FMIPv6 Implementation)
 * 
 *     //EXTRA
 *     ICMPv6_RPL_CONTROL_MESSAGE = 155; //RFC 6550, section 6, page 30
 * }
 * 
 * 
 * //cplusplus {{
 * //typedef int ICMPv6Code;
 * //}}
 * </pre>
 */
enum ICMPv6Type {
    ICMPv6_UNSPECIFIED = 0,
    ICMPv6_DESTINATION_UNREACHABLE = 1,
    ICMPv6_PACKET_TOO_BIG = 2,
    ICMPv6_TIME_EXCEEDED = 3,
    ICMPv6_PARAMETER_PROBLEM = 4,
    ICMPv6_ECHO_REQUEST = 128,
    ICMPv6_ECHO_REPLY = 129,
    ICMPv6_MLD_QUERY = 130,
    ICMPv6_MLD_REPORT = 131,
    ICMPv6_MLD_DONE = 132,
    ICMPv6_ROUTER_SOL = 133,
    ICMPv6_ROUTER_AD = 134,
    ICMPv6_NEIGHBOUR_SOL = 135,
    ICMPv6_NEIGHBOUR_AD = 136,
    ICMPv6_REDIRECT = 137,
    ICMPv6_MLDv2_REPORT = 143,
    ICMPv6_EXPERIMENTAL_MOBILITY = 150,
    ICMPv6_RPL_CONTROL_MESSAGE = 155
};

/**
 * Enum generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:83</tt> by nedtool.
 * <pre>
 * //EXTRA
 * //values of code field
 * enum ICMPv6_RPL_CONTROL_MSG
 * {
 * 
 *     DIS = 0x00;
 *     DIO = 0x01;
 * }
 * </pre>
 */
enum ICMPv6_RPL_CONTROL_MSG {
    DIS = 0x00,
    DIO = 0x01
};

/**
 * Enum generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:91</tt> by nedtool.
 * <pre>
 * //EXTRA
 * //DIS options
 * enum RPL_DIS_OPTIONS
 * {
 * 
 *     PAD1 = 0x00;
 *     PADN = 0x01;
 *     Solicited_Information = 0x07;
 * }
 * </pre>
 */
enum RPL_DIS_OPTIONS {
    PAD1 = 0x00,
    PADN = 0x01,
    Solicited_Information = 0x07
};

/**
 * Enum generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:101</tt> by nedtool.
 * <pre>
 * //
 * // ICMPv6 "codes" for type ICMPv6_DESTINATION_UNREACHABLE
 * //
 * enum ICMPv6DEST_UN
 * {
 * 
 *     NO_ROUTE_TO_DEST = 0;
 *     COMM_WITH_DEST_PROHIBITED = 1;
 *     //2 - NOT ASSIGNED
 *     ADDRESS_UNREACHABLE = 3;
 *     PORT_UNREACHABLE = 4;
 * }
 * </pre>
 */
enum ICMPv6DEST_UN {
    NO_ROUTE_TO_DEST = 0,
    COMM_WITH_DEST_PROHIBITED = 1,
    ADDRESS_UNREACHABLE = 3,
    PORT_UNREACHABLE = 4
};

/**
 * Enum generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:115</tt> by nedtool.
 * <pre>
 * //
 * // ICMPv6 "codes" for type ICMPv6_TIME_EXCEEDED
 * //
 * enum ICMPv6_TIME_EX
 * {
 * 
 *     ND_HOP_LIMIT_EXCEEDED = 0;
 *     ND_FRAGMENT_REASSEMBLY_TIME = 1;
 * }
 * </pre>
 */
enum ICMPv6_TIME_EX {
    ND_HOP_LIMIT_EXCEEDED = 0,
    ND_FRAGMENT_REASSEMBLY_TIME = 1
};

/**
 * Enum generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:125</tt> by nedtool.
 * <pre>
 * //
 * // ICMPv6 "codes" for type ICMPv6_PARAMETER_PROBLEM
 * //
 * enum ICMPv6_PARAMETER_PROB
 * {
 * 
 *     ERROREOUS_HDR_FIELD = 0;
 *     UNRECOGNIZED_NEXT_HDR_TYPE = 1;
 *     UNRECOGNIZED_IPV6_OPTION = 2;
 * }
 * </pre>
 */
enum ICMPv6_PARAMETER_PROB {
    ERROREOUS_HDR_FIELD = 0,
    UNRECOGNIZED_NEXT_HDR_TYPE = 1,
    UNRECOGNIZED_IPV6_OPTION = 2
};

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:143</tt> by nedtool.
 * <pre>
 * //
 * // Represents an ICMPv6 packet.
 * //
 * // Notes:
 * //    1. number of octets excluding the error datagram that is usually appended
 * //       in optInfo, i.e. the Type|CODE|CHECKSUM|UNUSED/POINTER/MTU/OTHER
 * //       as defined in RFC2463
 * //    2. Any ICMP type with MSB set, i.e. >=128 is an Informational ICMP message
 * //
 * packet ICMPv6Message
 * {
 *     int type \@enum(ICMPv6Type);
 *         //int code; //TODO: this should be specific to different ICMP types.
 * }
 * </pre>
 */
class ICMPv6Message : public ::omnetpp::cPacket
{
  protected:
    int type;

  private:
    void copy(const ICMPv6Message& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6Message&);

  public:
    ICMPv6Message(const char *name=nullptr, short kind=0);
    ICMPv6Message(const ICMPv6Message& other);
    virtual ~ICMPv6Message();
    ICMPv6Message& operator=(const ICMPv6Message& other);
    virtual ICMPv6Message *dup() const override {return new ICMPv6Message(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6Message& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6Message& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:153</tt> by nedtool.
 * <pre>
 * //
 * // Notes:
 * //   1. As defined in RFC2463: Section 3
 * //
 * packet ICMPv6DestUnreachableMsg extends ICMPv6Message
 * {
 *     int code \@enum(ICMPv6DEST_UN);
 * }
 * </pre>
 */
class ICMPv6DestUnreachableMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;

  private:
    void copy(const ICMPv6DestUnreachableMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6DestUnreachableMsg&);

  public:
    ICMPv6DestUnreachableMsg(const char *name=nullptr, short kind=0);
    ICMPv6DestUnreachableMsg(const ICMPv6DestUnreachableMsg& other);
    virtual ~ICMPv6DestUnreachableMsg();
    ICMPv6DestUnreachableMsg& operator=(const ICMPv6DestUnreachableMsg& other);
    virtual ICMPv6DestUnreachableMsg *dup() const override {return new ICMPv6DestUnreachableMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6DestUnreachableMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6DestUnreachableMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:158</tt> by nedtool.
 * <pre>
 * packet ICMPv6PacketTooBigMsg extends ICMPv6Message
 * {
 *     int code; //Set to 0 by sender and ignored by receiver.
 *     int MTU; //MTU of next-hop link
 * }
 * </pre>
 */
class ICMPv6PacketTooBigMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;
    int MTU;

  private:
    void copy(const ICMPv6PacketTooBigMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6PacketTooBigMsg&);

  public:
    ICMPv6PacketTooBigMsg(const char *name=nullptr, short kind=0);
    ICMPv6PacketTooBigMsg(const ICMPv6PacketTooBigMsg& other);
    virtual ~ICMPv6PacketTooBigMsg();
    ICMPv6PacketTooBigMsg& operator=(const ICMPv6PacketTooBigMsg& other);
    virtual ICMPv6PacketTooBigMsg *dup() const override {return new ICMPv6PacketTooBigMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getMTU() const;
    virtual void setMTU(int MTU);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6PacketTooBigMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6PacketTooBigMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:164</tt> by nedtool.
 * <pre>
 * packet ICMPv6TimeExceededMsg extends ICMPv6Message
 * {
 *     int code \@enum(ICMPv6_TIME_EX);
 * }
 * </pre>
 */
class ICMPv6TimeExceededMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;

  private:
    void copy(const ICMPv6TimeExceededMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6TimeExceededMsg&);

  public:
    ICMPv6TimeExceededMsg(const char *name=nullptr, short kind=0);
    ICMPv6TimeExceededMsg(const ICMPv6TimeExceededMsg& other);
    virtual ~ICMPv6TimeExceededMsg();
    ICMPv6TimeExceededMsg& operator=(const ICMPv6TimeExceededMsg& other);
    virtual ICMPv6TimeExceededMsg *dup() const override {return new ICMPv6TimeExceededMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6TimeExceededMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6TimeExceededMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:169</tt> by nedtool.
 * <pre>
 * packet ICMPv6ParamProblemMsg extends ICMPv6Message
 * {
 *     int code \@enum(ICMPv6_PARAMETER_PROB);
 * }
 * </pre>
 */
class ICMPv6ParamProblemMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;

  private:
    void copy(const ICMPv6ParamProblemMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6ParamProblemMsg&);

  public:
    ICMPv6ParamProblemMsg(const char *name=nullptr, short kind=0);
    ICMPv6ParamProblemMsg(const ICMPv6ParamProblemMsg& other);
    virtual ~ICMPv6ParamProblemMsg();
    ICMPv6ParamProblemMsg& operator=(const ICMPv6ParamProblemMsg& other);
    virtual ICMPv6ParamProblemMsg *dup() const override {return new ICMPv6ParamProblemMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6ParamProblemMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6ParamProblemMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:178</tt> by nedtool.
 * <pre>
 * //
 * // ICMPv6 Echo Request packet (RFC2463: Section 4).
 * // Data is attached through encapsulation (see ICMPv6.cc)
 * //
 * packet ICMPv6EchoRequestMsg extends ICMPv6Message
 * {
 *     int code; //set to 0.
 *     int identifier; // identifier to aid in matching Echo replies. May be Zero
 *     int seqNumber; // sequence number to aid in matching Echo replies. May be Zero
 *         //Data is attached through encapsulation. See ICMPv6.cc
 * }
 * </pre>
 */
class ICMPv6EchoRequestMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;
    int identifier;
    int seqNumber;

  private:
    void copy(const ICMPv6EchoRequestMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6EchoRequestMsg&);

  public:
    ICMPv6EchoRequestMsg(const char *name=nullptr, short kind=0);
    ICMPv6EchoRequestMsg(const ICMPv6EchoRequestMsg& other);
    virtual ~ICMPv6EchoRequestMsg();
    ICMPv6EchoRequestMsg& operator=(const ICMPv6EchoRequestMsg& other);
    virtual ICMPv6EchoRequestMsg *dup() const override {return new ICMPv6EchoRequestMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getIdentifier() const;
    virtual void setIdentifier(int identifier);
    virtual int getSeqNumber() const;
    virtual void setSeqNumber(int seqNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6EchoRequestMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6EchoRequestMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:189</tt> by nedtool.
 * <pre>
 * //
 * // ICMPv6 Echo Reply packet. Data is attached through encapsulation (see ICMPv6.cc)
 * //
 * packet ICMPv6EchoReplyMsg extends ICMPv6Message
 * {
 *     int code; //set to 0.
 *     int identifier; // identifier to aid in matching Echo replies. May be Zero
 *     int seqNumber; // sequence number to aid in matching Echo replies. May be Zero
 * }
 * </pre>
 */
class ICMPv6EchoReplyMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;
    int identifier;
    int seqNumber;

  private:
    void copy(const ICMPv6EchoReplyMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6EchoReplyMsg&);

  public:
    ICMPv6EchoReplyMsg(const char *name=nullptr, short kind=0);
    ICMPv6EchoReplyMsg(const ICMPv6EchoReplyMsg& other);
    virtual ~ICMPv6EchoReplyMsg();
    ICMPv6EchoReplyMsg& operator=(const ICMPv6EchoReplyMsg& other);
    virtual ICMPv6EchoReplyMsg *dup() const override {return new ICMPv6EchoReplyMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getIdentifier() const;
    virtual void setIdentifier(int identifier);
    virtual int getSeqNumber() const;
    virtual void setSeqNumber(int seqNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6EchoReplyMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6EchoReplyMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:198</tt> by nedtool.
 * <pre>
 * //EXTRA 
 * //DIS control message for RPL
 * packet ICMPv6DISMsg extends ICMPv6Message
 * {
 *     int code \@enum(ICMPv6_RPL_CONTROL_MSG); // RFC 6550, section 6: set to 0x00
 *     // TODO: checksum 
 *     int flags; // RFC 6550, section 6.2.1: set to 0
 *     int reserved; // RFC 6550, section 6.2.1 set to 0
 * 
 *     int RPLInstanceID;          // The ID of the RPL instance
 *     int VersionNumber;          // DODAG version number
 *     int V;                      // Node's rank
 *     int I;                      // Type of the DODAG, Grounded or Flooding
 *     int D;                      // Destination Advertisement Trigger Sequence Number       
 *     int Flag;                   // The size of Imin in Trcikle algorithm
 *     IPv6Address DODAGID;   // IPv6 address set by DODAG root  
 * 
 *     int options \@enum(RPL_DIS_OPTIONS); //RFC 6550, section 6.2.1
 * }
 * </pre>
 */
class ICMPv6DISMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;
    int flags;
    int reserved;
    int RPLInstanceID;
    int VersionNumber;
    int V;
    int I;
    int D;
    int Flag;
    IPv6Address DODAGID;
    int options;

  private:
    void copy(const ICMPv6DISMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6DISMsg&);

  public:
    ICMPv6DISMsg(const char *name=nullptr, short kind=0);
    ICMPv6DISMsg(const ICMPv6DISMsg& other);
    virtual ~ICMPv6DISMsg();
    ICMPv6DISMsg& operator=(const ICMPv6DISMsg& other);
    virtual ICMPv6DISMsg *dup() const override {return new ICMPv6DISMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getFlags() const;
    virtual void setFlags(int flags);
    virtual int getReserved() const;
    virtual void setReserved(int reserved);
    virtual int getRPLInstanceID() const;
    virtual void setRPLInstanceID(int RPLInstanceID);
    virtual int getVersionNumber() const;
    virtual void setVersionNumber(int VersionNumber);
    virtual int getV() const;
    virtual void setV(int V);
    virtual int getI() const;
    virtual void setI(int I);
    virtual int getD() const;
    virtual void setD(int D);
    virtual int getFlag() const;
    virtual void setFlag(int Flag);
    virtual IPv6Address& getDODAGID();
    virtual const IPv6Address& getDODAGID() const {return const_cast<ICMPv6DISMsg*>(this)->getDODAGID();}
    virtual void setDODAGID(const IPv6Address& DODAGID);
    virtual int getOptions() const;
    virtual void setOptions(int options);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6DISMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6DISMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/networklayer/icmpv6/ICMPv6MessageRPL.msg:218</tt> by nedtool.
 * <pre>
 * //EXTRA 
 * //DIO control message for RPL
 * packet ICMPv6DIOMsg extends ICMPv6Message
 * {
 *     int code \@enum(ICMPv6_RPL_CONTROL_MSG); // RFC 6550, section 6: set to 0x01
 *     // TODO: checksum 
 *     //int rplInstanceId = 0; // RFC 6550, section 6.3.1
 *     int versionNumber = 0; // RFC 6550, section 6.3.1
 *     int rank = 0;
 *     int grounded;
 *     //0
 *     //MOP
 *     //Prf
 *     //int flags = 0; // RFC 6550, section 6.3.1
 *     //int reserved = 0; // RFC 6550, section 6.3.1
 *     int DTSN;                 // Destination Advertisement Trigger Sequence Number       
 *     double IMin;              // The size of Imin in Trcikle algorithm
 *     int NofDoub;              // Number of doubling in Trcikle algorithm
 *     int k;                    // Redundancy constant in Trcikle algorithm
 *     IPv6Address DODAGID;              // IPv6 address set by DODAG root 
 * 
 * 
 * 
 *     int options \@enum(RPL_DIS_OPTIONS); //RFC 6550, section 6.3.1
 * }
 * </pre>
 */
class ICMPv6DIOMsg : public ::rpl::ICMPv6Message
{
  protected:
    int code;
    int versionNumber;
    int rank;
    int grounded;
    int DTSN;
    double IMin;
    int NofDoub;
    int k;
    IPv6Address DODAGID;
    int options;

  private:
    void copy(const ICMPv6DIOMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ICMPv6DIOMsg&);

  public:
    ICMPv6DIOMsg(const char *name=nullptr, short kind=0);
    ICMPv6DIOMsg(const ICMPv6DIOMsg& other);
    virtual ~ICMPv6DIOMsg();
    ICMPv6DIOMsg& operator=(const ICMPv6DIOMsg& other);
    virtual ICMPv6DIOMsg *dup() const override {return new ICMPv6DIOMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
    virtual int getVersionNumber() const;
    virtual void setVersionNumber(int versionNumber);
    virtual int getRank() const;
    virtual void setRank(int rank);
    virtual int getGrounded() const;
    virtual void setGrounded(int grounded);
    virtual int getDTSN() const;
    virtual void setDTSN(int DTSN);
    virtual double getIMin() const;
    virtual void setIMin(double IMin);
    virtual int getNofDoub() const;
    virtual void setNofDoub(int NofDoub);
    virtual int getK() const;
    virtual void setK(int k);
    virtual IPv6Address& getDODAGID();
    virtual const IPv6Address& getDODAGID() const {return const_cast<ICMPv6DIOMsg*>(this)->getDODAGID();}
    virtual void setDODAGID(const IPv6Address& DODAGID);
    virtual int getOptions() const;
    virtual void setOptions(int options);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ICMPv6DIOMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ICMPv6DIOMsg& obj) {obj.parsimUnpack(b);}

} // namespace rpl

#endif // ifndef __RPL_ICMPV6MESSAGERPL_M_H

